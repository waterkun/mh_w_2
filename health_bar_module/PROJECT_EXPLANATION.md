# 项目原理解析与文件说明

本文档旨在深入解释本项目核心的血条检测算法逻辑，并梳理各个代码文件的具体作用。

## 1. 核心逻辑：“看绿色条延伸到了哪里”

在 `health_bar_detector.py` 中，我们并没有使用简单的“统计绿色像素总数”的方法，而是采用了 **“基于跨度（Span-based）”** 的检测策略。

### 为什么这样做？
游戏中的血条通常不是纯色的矩形。它们往往包含：
- **纹理与渐变**：血条内部可能有深浅不一的绿色。
- **动态效果**：例如波浪动画，导致血条中间可能出现瞬间的暗色区域。
- **图标遮挡**：血条上可能有分隔线或状态图标。

如果单纯统计绿色像素的数量，上述因素会导致计算出的血量百分比在静止状态下也会发生微小的抖动（例如在 99% 和 98% 之间跳动）。

### 算法步骤

为了解决这个问题，我们模仿人类看血条的方式——**看血条的最右端在哪里**。

1.  **ROI 裁剪 (Crop)**：
    首先根据预设坐标（`DEFAULT_ROI`）从屏幕截图中切出血条区域。

2.  **颜色分离 (HSV Masking)**：
    将图片转换为 HSV 空间，利用阈值提取出“绿色部分”和“红色部分”（虚血/伤害）。

3.  **列扫描 (Column Projection)**：
    将二维图像压缩为一维数组。我们遍历血条的每一列（垂直方向），如果这一列中绿色像素的比例超过 5%（`COL_FILL_THRESHOLD`），我们就标记这一列为 **“存在绿色”**。

4.  **寻找边缘 (Find the Edge)**：
    这是最关键的一步。算法不关心中间是否有断裂，而是寻找 **最右侧的一个绿色列的索引位置**。

    $$ \text{血量百分比} = \frac{\text{最右侧绿色列的索引} + 1}{\text{血条总有效宽度}} $$

通过这种方式，只要血条的边缘被清晰识别，中间的纹理噪点就不会影响最终的读数，从而获得极高的稳定性。

---

## 2. 项目文件作用详解

### 根目录
- **`README.md`**
    - 项目的主文档，包含安装指南、环境要求和使用说明。

### `health_bar_photos/` (资源文件夹)
- 存放用于离线测试的游戏截图（如满血、残血、受击瞬间的截图）。
- 用于在不启动游戏的情况下调试算法。

### `mh_w_2_health_bar/` (核心代码库)

- **`health_bar_detector.py` (视觉层)**
    - **作用**：项目的“眼睛”。
    - **功能**：负责图像处理。输入一张图片，输出当前帧的血量百分比和伤害百分比。它不保存状态，只关心当前这一帧。

- **`health_bar_tracker.py` (逻辑层)**
    - **作用**：项目的“大脑”。
    - **功能**：负责时序逻辑。它记录上一帧的状态，通过对比前后帧来判断“是否刚刚受击”、“是否死亡”。同时负责计算强化学习（RL）需要的奖励信号（Reward Signal）。

- **`main.py` (执行入口)**
    - **作用**：实时运行脚本。
    - **功能**：调用 `mss` 进行屏幕截取，将图像传给 Detector 和 Tracker，并使用 OpenCV 绘制可视化调试窗口。

- **`test_detector.py` (测试脚本)**
    - **作用**：离线验证工具。
    - **功能**：读取 `health_bar_photos/` 中的静态图片并运行检测器，用于验证算法在不同血量状态下的准确性。

- **`requirements.txt`**
    - Python 依赖列表（如 `opencv-python`, `numpy`, `mss` 等）。